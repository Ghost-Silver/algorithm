## 归并排序
### 算法原理：
现在还是沿用牌堆的比喻：<br>
一共两个操作：<br>

1.分解：<br>
现在我们将牌分为两堆，对其中的每一堆都进行 '分为两堆' 这个操作，直到单个堆的元素只有一个<br>
**此时每个牌堆都是有序的**<br>

2.合并<br>
我们对每两个临近的牌堆（记为A、B）进行：<br>
当前每个牌堆仅一张牌，我们比较A和B的大小，将其中较小的一张牌放在另一张的上面<br>
<br>
以此类推，对34、56、78...号牌堆进行这个操作<br>
这样，我们获得了若干个单个都有序的牌堆

接下来，我们继续取临近的两个牌堆（记为A、B），进行：<br>
取出两堆顶上的一张，比较大小，将其中较小的放入手中，重复这个操作（如果此时手中有牌，那么放于上一张的下面），直到**至少一堆**已空<br>
那么这时，一共会有3种情况：<br>
1.两堆均空<br>
2.A空<br>
3.B空<br>

对于1，我们继续合并34、56、78...号牌堆，重复这个操作<br>
对于2、3，显然，此时剩余的所有元素一定比单独的这一堆中最大的都大，读者可以自己尝试证明一下（提示：反证法）<br>

那么我们可以将剩余的所有元素都直接按序排在单独这一堆后<br>
（严格证明见下文）
<br>

我们继续重复合并操作，直到只剩一堆，那么此时的牌堆就是有序的，排序完成<br>

### 具体算法实现
我们规定，a为待排序数组，共有n个元素(0 to n-1)<br>
l为目前区间的左端点，r为右端点，mid为中间点<br>
其中mid = l+(r-l)/2   **(至于为什么这么做，而不是简单的(l+r)/2,请看下文)**<br>

开始时，$l = 0，r = n-1，mid = l+(r-l)/2$
我们执行两个操作：<br>
1.分解：令a分为[l,mid]、[mid+1,r]两段，对子段继续按此分解，直到l=r（即单一元素）<br>

2.合并：<br>
我们每次合并[l,mid]、[mid+1,r]两段，保证每段内部都是有序的
也就是说，我们需要一个合并函数，类似：merge(a,l,r,mid)<br>
将[l,mid]记为L，[mid+1,r]记为R，再定义一个辅助数组tmp，用来保存合并完的数组，之后拷贝到数组a<br>

令k为当前tmp的下标，开始时k=0<br>
令i,j为当前L、R的下标，开始时为0<br>

然后：如果L[i]>=R[j]，那么tmp[k] = L[i],i--;<br>
    否则tmp[k] = R[j],j--；<br>

重复直到至少其中一堆的top < 0（即堆中没有任何数）；<br>
随后，我们将剩余的所有元素拷贝至tmp的末尾<br>

等到合并完的区间就等于a时，算法结束， a数组有序；

### 循环不变式证明
P.S. 这里的证明方式更通俗，《算法导论》给出了另外一种证明
> 由于分解这一步仅仅相当于分解问题为多个子问题，因此，我们不对这个阶段证明循环不变式
> 
那么，我们列出合并阶段的循环不变式：<br>
记住：在过程中，我们力图维护的，就是其循环不变式<br>
那么，我们其实一直在维护的是tmp数组的有序性<br>
所以，循环不变式为：
> tmp[0..k]始终保存L[0..i]、R[0..j]中前k小的数<br>
> 前提条件：子序列LR均有序
> 
我们开始证明：<br>
1.初始化： 此时tmp中什么也没有，因此符合循环不变式<br>
2.保持：在算法过程中，我们有两个阶段：<br>
- 一、在两个子序列均非空时，我们每次取L[i]、R[j]中较小的那一个
- 二、在至少一个为空时，我们将剩余的所有元素直接移动到tmp末尾<br>
<br>
我们挨个证明，
- 一、若取了$L[i]、R[j]$中较小的那一个导致tmp无序，那么说明有一个数$M>min(L[i]、R[j])$且在tmp中，而M一定来自L、R其中一个数组；<br><br>
若M来自于$min(L[i]、R[j])$所在的数组，那么说明此数组无序，于前提不符，所以不存在这样的M，即tmp有序；<br>
<br>若M来自于$max(L[i]、R[j])$所在的数组，那么说明，在选择M的那一轮循环中，M为较小的，因此另一堆剩余的所有元素一定都大于M，M这一堆剩余的所有元素也一定都大于M
<br>所以之后不会存在一个比M小的数$min(L[i]、R[j])$了，与前提不符，所以不存在这样的M；<br><br>
- 二、若这个操作导致tmp无序，那么在剩余这一堆中一定存在一个数Q，使得$Q<tmp[k]$，那么，tmp[k]只可能来自L、R<br>
如果和Q同堆，那么由于$Q<tmp[k]$，说明此堆无序，所以不存在Q<br>若不同堆，那么说明这一堆剩余所有元素均大于tmp[k]，则剩余的堆应该是这一堆，与假设不符；

$Q.E.D$
### 形式化的循环不变式证明：
形式化定义：
设 $L[1..m]$ 和 $R[1..p]$ 为有序数组，合并时不变式：
$temp[1..k]$ 包含 $L[1..i]$ 和 $R[1..j]$ 中前 $k$ 小元素且有序

数学归纳证明：

初始化：$k=0, i=1, j=1$，空数组满足条件
保持：
若 $L[i] \leq R[j]$，则 $L[i]$ 是剩余元素最小者
由归纳假设 $temp[1..k]$ 有序，追加 $L[i]$ 仍有序
终止：$i>m$ 或 $j>p$ 时，剩余元素直接追加仍有序

### 为什么是mid = l+(r-l)/2
我们先尝试展开：
**$mid = l+(r-l)/2 = l+0.5r-0.5l = 0.5r+0.5l = 1/2(r+l)$**;<br>
与直接$mid = (l+r)/2$本质上是一致的<br>

那么为什么还要变形呢<br>
想这样一个问题：倘若r、l均取int类型的最大值的一半+1，$mid = (l+r)/2$会发生什么呢<br>
**显然，$l+r$超过了int类型的最大值，会导致溢出**<br>
综上，我们选择$mid = l+(r-l)/2$；

### 关于位运算的一些奇技淫巧
我们注意到：在$mid = l+(r-l)/2$中需要计算一个$/2$的操作<br>
那么，有请位运算——快速乘除法<br>
原理 ：在进行乘除运算时，如果乘数或除数是 2 的幂次方，可以利用位移运算来替代乘除法操作<br>
左移一位相当于乘以 2，右移一位相当于除以 2<br>
例如，num << n 等价于 num * 2^n，num >> n 等价于 num / 2^n<br>
所以，我们可以改为：mid = (l+(r-l))>>1 （位运算的优先级更低，需要单独加括号）<br>
Upt 2025.8.6<br>
GhostSilver