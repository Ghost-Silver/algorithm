## 插入排序
### 算法原理：
插入排序与我们手动整理一副牌的过程类似（这里我们引用算法导论上的比喻）<br>

(注意，目前为了易读，我们讨论升序排序，对于非升序，参考insertion_sort(插入排序).h中的注释<br>

想象一下：你现在右手放着一副乱序的牌，左手开始时什么都没有<br>
我们规定：右手的牌是无序的，左手始终有序<br>
那么，我们现在从右手拿出一张牌，放到左手中<br>
此时，你左手的牌仍然有序，因为此时只有一张牌，符合规定<br>
接着，我们去拿下一张牌，这时有两种情况：<br>
1.当前的牌面>=左手牌面<br>
2.当前的牌面<左手牌面<br>
对于1，我们直接将牌放于左手的顶部即可<br>
对于2，我们需要将牌放于左手第一张的下面

让我们重复这个过程：<br>
1.取出一张牌，我们记录它的值为key<br>
2.从左手的第一张开始，逐个比较(我们记为A[j])，直到key<=A[j]，执行3<br>
3.那么此时，A[j+1]就是key这个值在左手上的正确位置，我们令A[j+1]=key，相当于把key插入到对应位置<br>
4.执行1-3，直到整个数列有序<br>

问题是，在计算机中，我们没办法执行`插入`这个操作，更具体的说，令A[j+1]=key时，会丢失A[j+1]的值

此时想想排牌时的操作：**当我们找到合适位置时，我们会将它右侧的所有牌右移一点，`腾出`一个空位来**<br>

#### 那么在算法中，我们应该怎么办呢？<br>
很简单，我们做一点点修改：<br>
在上述的过程2中，如果我们发现key>A[j]，我们令A[j+1] = A[j]<br>

可以试验一下：
假设左手牌为：2，4<br>
当前的key = 3<br>
当前的j = 1（C++索引从0开始）<br>
执行2:**由于4>key，我们让A[j+1] = A[j]，即A[2] = A[1]**<br>
那么，此时A[j]已经复制到了A[j+1]，我们无论怎么操作都不会丢失A[j]的数据，相当于腾出来了一个空位<br>

继续执行2:  此时的j = 0，A[j] = A[0] = 2<key，执行3<br>
执行3:  此时，A[j+1]就是key在左手的正确位置，所以令A[j+1]=key，而此时的A[j+1]就是上一轮的A[j]（因为每次j都会-1）<br>
而上一轮的A[j]已复制到上一轮的A[j+1]也就是当前的A[j+2]<br>
所以**我们可以直接令A[j+1]=key，不会丢失任何数据**

**只要我们持续这个操作，右手的所有牌最终都会正确地到达左手的正确位置**

### 如何形式化的验证算法正确性：
算法导论给我们提供了一个方法，类似数学归纳法--**“循环不变式”**
> 关于循环不变式的详解：参考docs/循环不变式.md
> 
我们来证明插入排序的循环不变式

#### 如何找循环不变式？

由于算法是一步步执行的，那么如果每一步（包括初试和结束）都满足一个共同的条件，那么这个条件就是要找的循环不变式（loop invariant）

显然的，我们一直在试图维护左手牌堆是有序的这个性质<br>
那么，插入排序的循环不变式就是：循环中，A[0…j-1]是有序的
<br>

接下来，我们证明循环不变式的三条性质：<br>
1.初始化：显然，j = 1时，A[0…j-1]就是A[0]，只有一个数字（这里我们提前将一张右手牌放入左手，并不影响结果），当然是符合循环不变式的<br>
2.保持：若 A[0..j-1] 有序，将 A[j] 插入后，A[0..j] 仍有序<br>
3.终止：终止时，当 j = n 时，A[0..n] 整体有序，排序完成<br>

**因此，插入排序最终被证明为正确的**
> 关于代码实现，参考insertion_sort(插入排序).h
> 
**P.S.在之后的算法设计文档中，我们都使用循环不变式来设计和证明算法**<br><br>
Upt 2025.8.3 <br>
GhostSilver
